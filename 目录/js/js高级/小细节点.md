## JS细节点总结：

##### 1.js的垃圾回收机制

A.创建内存地址->使用内存地址->回收内存地址

B.回收原理：标记清除（常用）和引用计数（现代浏览器不常用）

- 标记清除

- 引用计数：就看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不需要了

  有个缺陷：就是循环引用，导致内存泄露

  内存泄露产生的原因：就是两个对象相互引用，尽管它们已不再使用，但是垃圾回收器不会进行回收

##### 2.数据结构

A.栈数据结构：先进后出，后进先出，eg：从一个管子里面取乒乓球

B.堆数据结构：按存放地址寻找，eg:拿票取快递

C.队列：先进先出，后进后出，eg：地铁排队

##### 3.js的内存机制

A.js内存空间：栈(stack)，堆(heap)，池(一般归类为栈)，**栈**存的是变量，**堆**存放的是复杂对象，**池**放的是常量，也就常量池

B.闭包中的变量，不是保存在栈中，而是保存在堆中，*这也就解释了函数之后为什么还可以引用到函数内部的变量*

```js
function A(){
   let i = 10;
    function B(){
        console.log(i)
    };
    return B();
}
A()
```

C.内存回收：

全局变量和局部变量的销毁：

- 全局变量：什么时候需要自动释放内存空间则很难判断，所以在开发中**尽量避免**使用全局变量
- 局部变量：当函数执行完毕，对应的函数作用域的变量就没必要存在了，因此垃圾回收机制很容易做出判断，并将其回收

Google的V8引擎，V8引擎中所有的JS对象都是通过**堆**来进行内存分配的

- 初始分配：当声明变量并赋值时，V8引擎就会在堆内存中给变量赋值
- 继续申请：当已申请的内存不足以存储变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的上线为止

V8引擎对堆内存中的JS对象进行**分代管理**

- 新生代：存活周期较短的JS对象，如临时变量、字符串等
- 旧生代：经过多次的垃圾回收依然存活，存活周期比较久的，如主控制器、服务器对象等

D.内存泄露识别的方法

内存泄露：对于持续运行的服务进程，必须及时释放不再用到的内存。否则，当内存占用越来越高，轻则影响系统性能，重则程序崩溃。**对于不再使用的资源，没有及时得到释放，叫做内存泄漏**

浏览器方法：

- 打开memory->找到timeline字段选上->左上角开启录制按钮->模拟用户输入->关闭录制按钮

命令行方法：

- 使用node提供的process.memoryUsage方法
- 判断内存泄漏，以`heapUsed`字段为准。





